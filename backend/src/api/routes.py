# backend/src/api/routes.py

from fastapi import APIRouter, HTTPException
from src.core.deriv_api import deriv
from src.trading.order_executor import order_executor, position_manager
from src.trading.bot import trading_bot
from src.utils.logger import logger
from src.config.settings import settings
from src.db.repositories.trade_history_repo import TradeHistoryRepo
from src.db.session import SessionLocal
from src.db.models.trade import Trade
from src.db.models.contract import Contract
from datetime import datetime, timedelta
import asyncio
from src.core.risk_manager import RiskState

router = APIRouter(prefix="/api", tags=["Trading API"])

# ============================================================
# BASIC BOT STATUS
# ============================================================
@router.get("/status")
async def status():
    return {"bot": "running", "symbol": settings.SYMBOL}

@router.get("/balance")
async def balance():
    current_balance = await deriv.get_balance()
    logger.info(f"Balance requested: {current_balance}")
    return {"balance": current_balance}

@router.post("/manual/{direction}")
async def manual_trade(direction: str):
    """Execute manual RISE or FALL trade"""
    # Convert direction to Deriv's contract type
    if direction.upper() == "RISE":
        deriv_side = "CALL"
    elif direction.upper() == "FALL":
        deriv_side = "PUT"
    else:
        raise HTTPException(400, "Direction must be 'rise' or 'fall'")
    
    trade_id = await order_executor.place_trade(
        deriv_side, 
        settings.TRADE_AMOUNT, 
        settings.SYMBOL,
        duration=5,
        duration_unit="t"
    )
    return {
        "trade_id": trade_id,
        "direction": direction.upper(),
        "amount": settings.TRADE_AMOUNT
    }


# ============================================================
# BOT CONTROL ENDPOINTS
# ============================================================
@router.post("/start")
async def start_bot():
    """Start the trading bot"""
    try:
        if not trading_bot.running:
            # Use asyncio.create_task to run in background
            asyncio.create_task(trading_bot.run())
            return {"status": "Bot started", "running": True}
        return {"status": "Bot already running", "running": True}
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        raise HTTPException(500, f"Failed to start bot: {e}")

@router.post("/stop")
async def stop_bot():
    """Stop the trading bot"""
    try:
        if trading_bot.running:
            await trading_bot.stop()  # Call the new stop method
            return {"status": "Bot stopped", "running": False}
        return {"status": "Bot already stopped", "running": False}
    except Exception as e:
        logger.error(f"Failed to stop bot: {e}")
        raise HTTPException(500, f"Failed to stop bot: {e}")

@router.get("/bot/status")
async def get_bot_status():
    return {
        "running": trading_bot.running,
        "symbol": settings.SYMBOL,
        "active_positions": position_manager.get_open_count()
    }

# ============================================================
# SIGNALS ENDPOINT
# ============================================================
@router.get("/trades/signals")
async def get_signals(limit: int = 10):
    """Get recent trading signals generated by the bot"""
    try:
        from src.trading.bot import trading_bot
        
        signals = trading_bot.get_recent_signals(limit=limit)
        
        if not signals:
            logger.warning("No signals in bot history - bot may not be running")
            return {
                "signals": [],
                "total_signals": 0,
                "rise_signals": 0,
                "fall_signals": 0,
                "bot_running": trading_bot.running,
                "signal_history_size": len(trading_bot.signal_history),
                "last_update": datetime.utcnow().isoformat()
            }
        
        # Count RISE/FALL signals
        rise_count = sum(1 for s in signals if str(s.get("direction", "")).upper() in ["RISE", "BUY", "CALL"])
        fall_count = sum(1 for s in signals if str(s.get("direction", "")).upper() in ["FALL", "SELL", "PUT"])
        
        logger.info(f"Returning {len(signals)} signals: {rise_count} RISE, {fall_count} FALL")
        
        # Convert signals to use consistent RISE/FALL terminology
        standardized_signals = []
        for signal in signals:
            sig = signal.copy()
            direction = str(sig.get("direction", "")).upper()
            if direction in ["BUY", "CALL"]:
                sig["direction"] = "RISE"
            elif direction in ["SELL", "PUT"]:
                sig["direction"] = "FALL"
            standardized_signals.append(sig)
        
        return {
            "signals": standardized_signals,
            "total_signals": len(signals),
            "rise_signals": rise_count,
            "fall_signals": fall_count,
            "bot_running": trading_bot.running,
            "signal_history_size": len(trading_bot.signal_history),
            "last_update": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.error(f"Error fetching signals: {e}", exc_info=True)
        return {
            "signals": [],
            "total_signals": 0,
            "rise_signals": 0,
            "fall_signals": 0,
            "error": str(e),
            "last_update": datetime.utcnow().isoformat()
        }

# ============================================================
# MARKET DATA
# ============================================================
@router.get("/market/data")
async def get_market_data():
    """Get current market data"""
    try:
        # You can implement actual price fetching here
        return {
            "symbol": settings.SYMBOL,
            "price": 0,  # Placeholder
            "status": "unknown"
        }
    except Exception as e:
        raise HTTPException(500, f"Failed to get market data: {e}")

# ============================================================
# TRADE HISTORY
# ============================================================
@router.get("/trades")
async def get_trades(limit: int = 100, offset: int = 0):
    """Fetch recent trades with contract details, using RISE/FALL terminology"""
    db = SessionLocal()
    try:
        trades_query = db.query(Trade).join(
            Contract, Trade.id == Contract.trade_id, isouter=True
        ).order_by(Trade.created_at.desc())

        total = trades_query.count()
        trades = trades_query.limit(limit).offset(offset).all()

        formatted_trades = []
        for trade in trades:
            # Convert side to RISE/FALL terminology
            raw_side = trade.side or getattr(trade, "direction", None) or getattr(trade, "consensus_direction", None)
            direction = "UNKNOWN"
            if raw_side:
                s = str(raw_side).upper()
                if s in ["RISE", "BUY", "CALL"]:
                    direction = "RISE"
                elif s in ["FALL", "SELL", "PUT"]:
                    direction = "FALL"
            
            # Determine if it's a Rise/Fall contract
            is_rise_fall = True  # All your 1-tick contracts are Rise/Fall
            
            # Build trade dict
            trade_dict = {
                "id": trade.id,
                "symbol": trade.symbol,
                "original_side": trade.side,  # Keep original for reference
                "direction": direction,  # Standardized direction (RISE/FALL)
                "contract_type": "Rise/Fall" if is_rise_fall else "Other",
                "amount": float(trade.amount) if trade.amount else 0,
                "duration": trade.duration,
                "status": trade.status,
                "created_at": trade.created_at.isoformat() if trade.created_at else None,
                "updated_at": trade.updated_at.isoformat() if hasattr(trade, "updated_at") and trade.updated_at else None
            }

            # Attach contract info if exists
            contracts = db.query(Contract).filter(Contract.trade_id == trade.id).all()
            if contracts:
                # Get the latest contract
                contract = contracts[0]
                trade_dict["contract"] = {
                    "profit": float(contract.profit) if contract.profit else 0,
                    "entry_tick": contract.entry_tick if contract.entry_tick else "â€”",
                    "exit_tick": contract.exit_tick if contract.exit_tick else "â€”",
                    "is_sold": contract.is_sold,
                    "sell_time": contract.sell_time.isoformat() if contract.sell_time else None
                }
            else:
                # Fabricate a contract object if none exists (to prevent undefined in frontend)
                profit = 0.0
                if trade.status == "WON":
                    profit = trade.amount * 0.95  # Approximate payout
                elif trade.status == "LOST":
                    profit = -trade.amount
                
                trade_dict["contract"] = {
                    "entry_tick": "N/A",
                    "exit_tick": "N/A",
                    "profit": profit,
                    "is_sold": "1" if trade.status in ["WON", "LOST"] else "0",
                    "sell_time": None
                }
            
            formatted_trades.append(trade_dict)

        return {
            "trades": formatted_trades,
            "pagination": {
                "limit": limit,
                "offset": offset,
                "total": total
            }
        }

    except Exception as e:
        logger.error(f"Error fetching trades: {e}", exc_info=True)
        return {
            "trades": [],
            "pagination": {
                "limit": limit,
                "offset": offset,
                "total": 0
            }
        }
    finally:
        db.close()


@router.get("/trades/{trade_id}")
async def get_trade(trade_id: str):
    db = SessionLocal()
    try:
        trade = db.query(Trade).filter(Trade.id == trade_id).first()
        if not trade:
            raise HTTPException(404, "Trade not found")
        
        # Convert side to RISE/FALL
        raw_side = trade.side or getattr(trade, "direction", None)
        direction = "UNKNOWN"
        if raw_side:
            s = str(raw_side).upper()
            if s in ["RISE", "BUY", "CALL"]:
                direction = "RISE"
            elif s in ["FALL", "SELL", "PUT"]:
                direction = "FALL"
        
        trade_data = {
            "id": trade.id,
            "symbol": trade.symbol,
            "original_side": trade.side,
            "direction": direction,
            "amount": float(trade.amount) if trade.amount else 0,
            "duration": trade.duration,
            "status": trade.status,
            "created_at": trade.created_at.isoformat() if trade.created_at else None,
            "contract_type": "Rise/Fall"
        }
        
        # Add contract details
        contract = db.query(Contract).filter(Contract.trade_id == trade_id).first()
        if contract:
            trade_data["contract"] = {
                "profit": float(contract.profit) if contract.profit else 0,
                "entry_tick": contract.entry_tick,
                "exit_tick": contract.exit_tick,
                "is_sold": contract.is_sold,
                "sell_time": contract.sell_time.isoformat() if contract.sell_time else None
            }
        
        return trade_data
    finally:
        db.close()

@router.get("/trades/status/{status}")
async def get_trades_by_status(status: str, limit: int = 100):
    valid_statuses = ["PENDING", "ACTIVE", "WON", "LOST", "ERROR"]
    if status.upper() not in valid_statuses:
        raise HTTPException(
            400, 
            f"Status must be one of: {valid_statuses}"
        )

    trades = TradeHistoryRepo.get_trades_by_status(
        status.upper(), limit=limit
    )
    
    # Convert trades to use RISE/FALL terminology
    formatted_trades = []
    for trade in trades:
        if isinstance(trade, dict):
            formatted_trade = trade.copy()
            direction = str(trade.get("side", "")).upper()
            if direction in ["BUY", "CALL"]:
                formatted_trade["direction"] = "RISE"
            elif direction in ["SELL", "PUT"]:
                formatted_trade["direction"] = "FALL"
            else:
                formatted_trade["direction"] = direction
            formatted_trades.append(formatted_trade)
    
    return {"trades": formatted_trades}

@router.get("/trades/stats/summary")
async def get_trading_stats():
    stats = TradeHistoryRepo.get_trading_stats()
    
    # Add RISE/FALL breakdown if available
    db = SessionLocal()
    try:
        rise_trades = db.query(Trade).filter(
            (Trade.side == "CALL") | (Trade.side == "BUY")
        ).count()
        fall_trades = db.query(Trade).filter(
            (Trade.side == "PUT") | (Trade.side == "SELL")
        ).count()
        
        stats["rise_trades"] = rise_trades
        stats["fall_trades"] = fall_trades
        stats["rise_ratio"] = round((rise_trades / (rise_trades + fall_trades)) * 100, 2) if (rise_trades + fall_trades) > 0 else 0
    finally:
        db.close()
    
    return stats

@router.get("/trades/date-range")
async def get_trades_by_date_range(start_date: str, end_date: str):
    try:
        trades = TradeHistoryRepo.get_trades_by_date_range(start_date, end_date)
        
        # Convert trades to use RISE/FALL terminology
        formatted_trades = []
        for trade in trades:
            if isinstance(trade, dict):
                formatted_trade = trade.copy()
                direction = str(trade.get("side", "")).upper()
                if direction in ["BUY", "CALL"]:
                    formatted_trade["direction"] = "RISE"
                elif direction in ["SELL", "PUT"]:
                    formatted_trade["direction"] = "FALL"
                else:
                    formatted_trade["direction"] = direction
                formatted_trades.append(formatted_trade)
        
        return {
            "trades": formatted_trades,
            "date_range": {
                "start_date": start_date,
                "end_date": end_date
            }
        }
    except ValueError as e:
        raise HTTPException(400, f"Invalid date format: {e}")


# ============================================================
# DEBUG ENDPOINTS
# ============================================================
@router.get("/debug/positions")
async def debug_positions():
    positions = position_manager.active_positions
    
    # Convert positions to use RISE/FALL terminology
    formatted_positions = {}
    for contract_id, pos in positions.items():
        formatted_pos = pos.copy()
        direction = str(pos.get("side", "")).upper()
        if direction in ["CALL", "BUY"]:
            formatted_pos["direction"] = "RISE"
        elif direction in ["PUT", "SELL"]:
            formatted_pos["direction"] = "FALL"
        formatted_positions[contract_id] = formatted_pos
    
    return {
        "open_positions": position_manager.get_open_count(),
        "active_positions": formatted_positions
    }

@router.get("/debug/bot")
async def debug_bot():
    return {
        "bot_running": trading_bot.running,
        "strategies": [s.name for s in trading_bot.strategies],
        "symbol": settings.SYMBOL,
        "trade_amount": settings.TRADE_AMOUNT,
        "contract_type": "Rise/Fall (1-tick)",
        "duration": settings.CONTRACT_DURATION
    }


# ============================================================
# PERFORMANCE + RISK METRICS
# ============================================================
@router.get("/performance/metrics")
async def get_performance_metrics():
    """Get current bot performance metrics"""
    try:
        metrics = trading_bot.get_bot_metrics()  # Remove 'await' here
        return metrics
    except Exception as e:
        logger.error(f"Error getting performance metrics: {e}")
        return {
            "running": trading_bot.running if hasattr(trading_bot, 'running') else False,
            "total_trades": 0,
            "win_rate": 0,
            "pnl": 0,
            "sharpe_ratio": 0,
            "total_profit": 0,
            "completed_trades": 0,
            "winning_trades": 0,
            "contract_type": "Rise/Fall"
        }

@router.get("/risk/metrics")
async def get_risk_metrics():
    metrics = trading_bot.risk.get_risk_metrics()
    # Add contract type info
    metrics["contract_type"] = "Rise/Fall"
    metrics["duration_ticks"] = settings.CONTRACT_DURATION
    return metrics

@router.post("/risk/reset")
async def reset_risk():
    trading_bot.risk.reset_streak()
    return {"status": "Risk streaks reset"}

@router.post("/risk/unlock")
async def manual_unlock():
    """Manually unlock trading if locked"""
    success = trading_bot.risk.manual_unlock()
    if success:
        # Also reset daily profit tracking
        trading_bot.risk.daily_profit = 0.0
        trading_bot.risk.daily_loss = 0.0
        logger.info("ðŸ’° Manual unlock: Reset daily profit/loss tracking")
        
        return {
            "status": "Trading unlocked and daily P&L reset",
            "daily_profit": trading_bot.risk.daily_profit,
            "daily_loss": trading_bot.risk.daily_loss,
            "net_daily_pnl": trading_bot.risk.get_net_daily_pnl()["net_daily_pnl"]
        }
    return {"status": "No lock to unlock"}

@router.post("/risk/reset-daily-profit")
async def reset_daily_profit():
    """Reset daily profit tracking to unlock trading"""
    success = trading_bot.risk.manual_unlock()
    if success:
        return {"status": "Daily profit tracking reset and trading unlocked"}
    return {"status": "No lock to reset"}

@router.get("/risk/lock-status")
async def get_lock_status():
    """Get detailed lock status information"""
    risk = trading_bot.risk
    
    # Calculate percentages
    start_balance = risk.start_day_balance or 0
    daily_loss_pct = (risk.daily_loss / start_balance) * 100 if start_balance > 0 else 0
    daily_profit_pct = (risk.daily_profit / start_balance) * 100 if start_balance > 0 else 0
    
    return {
        "state": risk.state.value,
        "locked_until": risk.locked_until,
        "daily_loss": {
            "amount": risk.daily_loss,
            "percentage": round(daily_loss_pct, 2),
            "limit_percentage": risk.daily_loss_limit_pct * 100
        },
        "daily_profit": {
            "amount": risk.daily_profit,
            "percentage": round(daily_profit_pct, 2),
            "limit_percentage": risk.daily_profit_limit_pct * 100
        },
        "start_balance": start_balance,
        "current_balance": await deriv.get_balance(),
        "is_locked": risk.state == RiskState.LOCKED,
        "lock_reason": "daily_loss" if daily_loss_pct >= risk.daily_loss_limit_pct * 100 else 
                      "daily_profit" if daily_profit_pct >= risk.daily_profit_limit_pct * 100 else 
                      "none",
        "contract_type": "Rise/Fall"
    }

# ============================================================
# STRATEGY PERFORMANCE
# ============================================================
@router.get("/strategies/performance")
async def get_strategies_performance():
    # Convert strategy performance to use RISE/FALL terminology
    perf = trading_bot.strategy_performance.copy()
    for strategy_name, data in perf.items():
        # Rename "calls" to "rise_signals" and "puts" to "fall_signals"
        if "calls" in data and "puts" in data:
            data["rise_signals"] = data.pop("calls")
            data["fall_signals"] = data.pop("puts")
    return perf


# ============================================================
# ML CONSENSUS STATUS
# ============================================================
@router.get("/ml/status")
async def get_ml_status():
    return {
        "ml_enabled": settings.ML_CONSENSUS_ENABLED,
        "model_trained": trading_bot.consensus.ml_consensus.is_trained,
        "training_samples": len(trading_bot.consensus.ml_consensus.training_data),
        "prediction_type": "RISE/FALL direction"
    }


# ============================================================
# RECOVERY SYSTEM ENDPOINTS
# ============================================================
@router.post("/recovery/reset")
async def reset_recovery():
    trading_bot.risk.reset_streak()
    return {
        "status": "Recovery system reset",
        "next_amount": trading_bot.risk.get_next_trade_amount(),
        "contract_type": "Rise/Fall"
    }

@router.get("/recovery/status")
async def get_recovery_status():
    status = trading_bot.risk.get_recovery_metrics()
    status["contract_type"] = "Rise/Fall"
    return status

@router.get("/recovery/simulate")
async def simulate_recovery(
    initial_loss: float = 10.0,
    max_streak: int = 3
):
    sequence = trading_bot.risk.simulate_recovery_sequence(
        initial_loss, max_streak
    )
    return {
        "simulation": sequence,
        "settings": {
            "recovery_mode": settings.RECOVERY_MODE,
            "multiplier": settings.RECOVERY_MULTIPLIER,
            "max_streak": settings.MAX_RECOVERY_STREAK,
            "smart_recovery": settings.SMART_RECOVERY,
            "contract_type": "Rise/Fall"
        }
    }

@router.post("/recovery/configure")
async def configure_recovery(
    enabled: bool = None,
    multiplier: float = None,
    max_streak: int = None,
    smart: bool = None,
    mode: str = None
):
    risk = trading_bot.risk

    if enabled is not None:
        risk.recovery_enabled = enabled

    if multiplier is not None and 1.0 <= multiplier <= 5.0:
        risk.recovery_multiplier = multiplier

    if max_streak is not None and 1 <= max_streak <= 10:
        risk.max_recovery_streak = max_streak

    if smart is not None:
        risk.smart_recovery = smart

    if mode in ["MARTINGALE", "FIBONACCI"]:
        risk.recovery_mode = mode

    return {
        "status": "Recovery configuration updated",
        "current": risk.get_recovery_metrics(),
        "contract_type": "Rise/Fall"
    }

@router.post("/trades/manual-settle/{trade_id}")
async def manual_settle_trade(trade_id: str, result: str = None, payout: float = None):
    """Manually settle a stuck trade"""
    db = SessionLocal()
    try:
        trade = db.query(Trade).filter(Trade.id == trade_id).first()
        if not trade:
            raise HTTPException(404, "Trade not found")
        
        # If result not provided, determine based on payout
        if result is None:
            if payout is None:
                result = "LOST"
                payout = 0.0
            else:
                result = "WON" if payout > 0 else "LOST"
        
        # Update trade
        trade.status = result
        if hasattr(trade, "updated_at"):
            trade.updated_at = datetime.utcnow()
        
        # Update contract if exists
        contract = db.query(Contract).filter(Contract.trade_id == trade_id).first()
        if contract:
            contract.profit = payout
            contract.is_sold = "1"
            contract.sell_time = datetime.utcnow()
        
        db.commit()
        
        # Update risk manager and performance
        from src.trading.order_executor import order_executor
        from src.trading.performance import performance
        
        order_executor.risk.update_trade_outcome(result, trade.amount)
        profit = payout - trade.amount if payout is not None else -trade.amount
        performance.add_trade({
            "id": trade_id,
            "symbol": trade.symbol,
            "side": trade.side,
            "amount": trade.amount,
            "profit": profit,
            "result": result,
            "closed_at": datetime.utcnow()
        })
        
        return {
            "status": "Trade manually settled",
            "trade_id": trade_id,
            "result": result,
            "payout": payout,
            "contract_type": "Rise/Fall"
        }
    finally:
        db.close()

@router.post("/trades/auto-settle-expired")
async def auto_settle_expired_trades():
    """Automatically settle trades that should have expired"""
    db = SessionLocal()
    try:
        cutoff = datetime.utcnow() - timedelta(minutes=3)
        expired_trades = db.query(Trade).filter(
            Trade.status == "ACTIVE",
            Trade.created_at < cutoff
        ).all()
        
        settled = []
        for trade in expired_trades:
            trade.status = "LOST"
            contract = db.query(Contract).filter(Contract.trade_id == trade.id).first()
            if contract:
                contract.profit = 0.0
                contract.is_sold = "1"
                contract.sell_time = datetime.utcnow()
            
            from src.trading.order_executor import order_executor
            from src.trading.performance import performance
            
            order_executor.risk.update_trade_outcome("LOST", trade.amount)
            performance.add_trade({
                "id": trade.id,
                "symbol": trade.symbol,
                "side": trade.side,
                "amount": trade.amount,
                "profit": -trade.amount,
                "result": "LOST",
                "closed_at": datetime.utcnow()
            })
            
            settled.append(trade.id)
            logger.info(f"Auto-settled expired Rise/Fall trade {trade.id} as LOST")
        
        db.commit()
        
        from src.trading.position_manager import position_manager
        for contract_id in list(position_manager.active_positions.keys()):
            pos = position_manager.active_positions.get(contract_id)
            if pos and pos.get("trade_id") in settled:
                position_manager.mark_closed(contract_id, "LOST", 0)
        
        return {
            "settled_count": len(settled),
            "settled_trades": settled,
            "contract_type": "Rise/Fall"
        }
    finally:
        db.close()

# ============================================================
# RISE/FALL SPECIFIC ENDPOINTS
# ============================================================
@router.get("/contract-type")
async def get_contract_type():
    """Get information about the contract type being traded"""
    return {
        "type": "Rise/Fall (Up/Down)",
        "description": "1-tick contract predicting if price will RISE (go up) or FALL (go down)",
        "duration_ticks": settings.CONTRACT_DURATION,
        "deriv_mapping": {
            "RISE": "CALL",
            "FALL": "PUT"
        },
        "payout_percentage": 82,  # Typical for Deriv Rise/Fall contracts
        "symbol": settings.SYMBOL
    }

@router.get("/trades/direction/{direction}")
async def get_trades_by_direction(direction: str, limit: int = 50):
    """Get trades by direction (RISE or FALL)"""
    if direction.upper() not in ["RISE", "FALL"]:
        raise HTTPException(400, "Direction must be 'rise' or 'fall'")
    
    db = SessionLocal()
    try:
        # Map direction to Deriv sides
        if direction.upper() == "RISE":
            sides = ["CALL", "BUY"]
        else:  # FALL
            sides = ["PUT", "SELL"]
        
        trades = db.query(Trade).filter(
            Trade.side.in_(sides)
        ).order_by(Trade.created_at.desc()).limit(limit).all()
        
        formatted_trades = []
        for trade in trades:
            formatted_trade = {
                "id": trade.id,
                "symbol": trade.symbol,
                "original_side": trade.side,
                "direction": direction.upper(),
                "amount": float(trade.amount) if trade.amount else 0,
                "duration": trade.duration,
                "status": trade.status,
                "created_at": trade.created_at.isoformat() if trade.created_at else None,
                "contract_type": "Rise/Fall"
            }
            formatted_trades.append(formatted_trade)
        
        return {
            "direction": direction.upper(),
            "trades": formatted_trades,
            "count": len(formatted_trades)
        }
    finally:
        db.close()